# 이벤트 핸들러

```
function handleChange(e: any) {
  const { name, value } = e.target;
  const nextValues = {
    ...values,
    [name]: value,
  };
  setValues(nextValues);
}
```
예제 코드의 이벤트 핸들러의 타입을 지정하자

```
function handleChange(e: ChangeEvent) {
  const { name, value } = e.target; // error
  // 타입스크립트는 e.target이 EventTarget 이라고 생각
  // EventTarget 타입에는 name, value 가 없어서 에러가 납니다
  const nextValues = {
    ...values,
    [name]: value,
  };
  setValues(nextValues);
}
```

## 원인

1. ChangeEvent의 일반성: React의 ChangeEvent를 사용해도, TypeScript는 e.target을 가장 일반적인 DOM 타입인 **EventTarget**으로 추론합니다.

2. EventTarget의 한계: EventTarget 타입에는 name과 value 속성이 정의되어 있지 않습니다.

3. 속성의 특정성: name과 value 속성은 **<input, <select, <textarea**  와 같은 특정 HTML 입력 요소 노드(HTMLInputElement, HTMLSelectElement 등)에만 존재합니다.

4. 결론: TypeScript는 e.target이 name과 value를 가지고 있는지 확신할 수 없기 때문에 에러를 발생시킵니다.
```
function handleChange(e: ChangeEvent<HTMLInputElement>) {
  const { name, value } = e.target;
  const nextValues = {
    ...values,
    [name]: value,
  };
  setValues(nextValues);
}

```

제네릭을 명시적 타입 지정

+ name, value 같은 속성은 <input ,select> 같은 특정타입의 노드에만 있다

+ ** ChangeEvent HTMLInputElement> ** 를 사용하여 명시적으로 지정

+ 이벤트의 타겟 노드는 name과 value 속성을 가진 html 입력 요소라고 알려주는것


보너스: 다양한 입력 요소를 처리할 떄

만약 하나의 handleChange 함수로 텍스트 입력 (HTMLInputElement)과 드롭다운 (HTMLSelectElement)을 동시에 처리해야 한다면, 유니온 타입을 사용하여 타입을 확장할 수 있습니다.


```
type FormElement = HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement;

function handleChange(e: ChangeEvent<FormElement>) {
    // ...
}
```